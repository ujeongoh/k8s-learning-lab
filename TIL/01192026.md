# Kubernetes Learning Journey ðŸš€

**Author:** Joy Oh
**Environment:** macOS (Apple Silicon M3) + Multipass (Ubuntu VMs)
**Tools:** kubeadm, kubectl, CNI(Calico), kube-proxy, Nginx Ingress

---

## Phase 3: Workloads & Troubleshooting (Deep Dive)

**Goal:** Deploy a multi-tier application (Guestbook), understand `kube-proxy` internals, and resolve architecture-specific challenges.

### 1. Kube-proxy vs. CNI (Theory)

**Concept:** Clarified the distinct roles of networking components.

* **CNI (Calico):** The "Road Builder." Assigns IP addresses to Pods and handles routing **between nodes** (L3 Connectivity).
* **Kube-proxy:** The "Navigation System." Runs on every node, manipulating kernel rules (**iptables** or IPVS) to handle Service abstraction. It performs **DNAT** to forward traffic from a virtual `ClusterIP` to an actual `PodIP`.

### 2. Backend Deployment (Redis) & Incident Report

**Scenario:** Deployed `redis-master` Deployment and Service.

* **Issue:** Pods stuck in `ContainerCreating` status.
* **Error Log:** `kubectl describe pod` revealed:
```text
plugin type="calico" failed: connection is unauthorized: Unauthorized
```


* **Root Cause:**
* The Control Plane was re-initialized (`kubeadm init`), generating new tokens.
* Worker nodes were reused without a full reset, retaining **stale CNI tokens** in `/etc/cni/net.d/` from the previous cluster setup.


* **Resolution:**
* Manually purged stale configurations on worker nodes:
```bash
sudo rm -rf /etc/cni/net.d/*
```


* Restarted Calico pods to force regeneration of valid config files.
* **Lesson:** Always perform a clean reset (`kubeadm reset` & cleanup) when reusing VMs for a new cluster.



### 3. Frontend Deployment (Guestbook) & ARM64 Compatibility

**Scenario:** Attempted to deploy the Frontend application to connect with Redis.

* **Trick:** Created a `redis-worker` Service pointing to the `redis-master` Pod using **Label Selectors** to save resources (simulating a read-replica).
* **Challenge:** The provided sample images (`gcr.io/google-samples/gb-frontend`) crashed repeatedly.
    * **Error:** `exec format error` or `CrashLoopBackOff`.
    * **Cause:** The sample images were built for **Intel (x86/amd64)** architecture, but the local environment is **Apple Silicon (ARM64)**.


* **Resolution:**
    * Attempted various community images (Go version, Hello-K8s), but encountered version mismatches.
    * Finally deployed **`nginx:alpine`** (a verified Multi-arch image) to validate the infrastructure pipeline.


* **Verification:**
    * Confirmed `Running` status on ARM64 nodes.
    * Successfully accessed via Ingress at `http://guestbook.local:30080`.



### 4. Service Mesh & Traffic Flow

* **Mesh Networking:** Verified that accessing **Worker Node 1**'s IP redirects traffic to a Pod located on **Worker Node 2**.
* **Mechanism:** `kube-proxy` and CNI work together to route traffic across the cluster, regardless of which node receives the initial request.
* **Host Configuration:** Mapped a single Node IP to `guestbook.local` in `/etc/hosts`, proving that specific Pod location awareness is not required for the client.

---

## ðŸ”œ Next Steps: Phase 4 (Storage & Config)

* **Persistent Volume (PV/PVC):** Preserving DB data even if Pods restart.
* **ConfigMaps & Secrets:** Decoupling configuration from application code.